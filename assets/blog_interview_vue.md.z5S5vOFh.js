import{_ as s,c as i,o as a,R as t}from"./chunks/framework.Tt2DsVC6.js";const c=JSON.parse('{"title":"VUE 面试问题","description":"","frontmatter":{},"headers":[],"relativePath":"blog/interview/vue.md","filePath":"blog/interview/vue.md","lastUpdated":1702369387000}'),e={name:"blog/interview/vue.md"},l=t(`<h1 id="vue-面试问题" tabindex="-1">VUE 面试问题 <a class="header-anchor" href="#vue-面试问题" aria-label="Permalink to &quot;VUE 面试问题&quot;">​</a></h1><h2 id="对-keep-alive-的理解" tabindex="-1">对 Keep-alive 的理解 <a class="header-anchor" href="#对-keep-alive-的理解" aria-label="Permalink to &quot;对 Keep-alive 的理解&quot;">​</a></h2><ul><li>keep-alive 是 Vue 内置的一个组件，能在切换组件过程中将状态保留在内存中，防止重复渲染 DOM</li><li>keep-alive 包裹动态组件时，会缓存不活动的组件实例，而不是销毁它们</li><li>keep-alive 可以设置以下 props： <ul><li>include: 字符串或正则表达式。只有匹配的组件会被缓存</li><li>exclude: 字符串或正则表达式。任何匹配的组件都不会被缓存</li><li>max: 最多可以缓存多少组件实例</li></ul></li><li>keep-alive 匹配首先检查组件的 name 选项，如果 name 选项不可用，则匹配它的局部注册名称(父组件 components 选项的键值)，匿名组件不能被匹配</li><li>keep-alive 的生命周期钩子: <ul><li>activated</li><li>deactivated</li></ul></li></ul><h2 id="双向数据绑定" tabindex="-1">双向数据绑定 <a class="header-anchor" href="#双向数据绑定" aria-label="Permalink to &quot;双向数据绑定&quot;">​</a></h2><p>vue 采用 <b>数据劫持</b> 结合 <b>发布-订阅者模式</b> 的方式, 通过 <span class="important">Object.defineProperty()</span> 来劫持各个属性的 <b>setter</b> 以及 <b>getter</b>, 在数据变动时发布消息给订阅者触发相应的监听回调.</p><h2 id="vue-项目优化" tabindex="-1">vue 项目优化 <a class="header-anchor" href="#vue-项目优化" aria-label="Permalink to &quot;vue 项目优化&quot;">​</a></h2><ul><li>关闭 sourceMap: 进行打包源码上线环节，需要对项目开发环节的开发提示信息以及错误信息进行屏蔽, 一方面可以减少上线代码包的大小; 另一方面提高系统的安全性.</li><li>对项目中的 js/css/svg 等资源开启 gzip 压缩</li><li>路由懒加载:</li></ul><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  path</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;index&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  component</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: () </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;@/views/user/index&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><ul><li>第三方插件按需引入</li><li>代码优化 <ul><li>v-if 和 v-show 选择调用: v-if 是懒加载，当状态为 true 时才会加载, 并且为 false 时不会占用布局空间; v-show 是无论状态是 true 或者是 false, 都会进行渲染，并对布局占据空间对于在项目中, 需要频繁调用, 不需要权限的显示隐藏，可以选择使用 v-show, 可以减少系统的切换开销.</li><li>列表循环时为 item 设置 key 值</li><li>减少 watch 数据: watch 监听的数据较大时, 系统会出现卡顿</li><li>系统图片资源按需加载</li></ul></li><li>提取 css 文件: vue-cli 脚手架使用了 extract-text-webpack-plugin 插件,可以将放在 head 中的 style 提取成 css 文件引入</li></ul><h2 id="vue-中-key-值的作用" tabindex="-1"><a href="https://cn.vuejs.org/v2/api/#key" target="_blank" rel="noreferrer">vue 中 key 值的作用</a> <a class="header-anchor" href="#vue-中-key-值的作用" aria-label="Permalink to &quot;[vue 中 key 值的作用](https://cn.vuejs.org/v2/api/#key)&quot;">​</a></h2><ul><li>v-for 列表循环中的 key: 作用就是在更新组件时判断两个节点是否相同。相同就复用，不相同就删除旧的创建新的.</li><li>其他作用: 用于强制更新元素/组件而不是重复使用 <ul><li>触发过渡</li><li>完整地触发组件的生命周期钩子</li></ul></li></ul><p>例如:</p><div class="language-html vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">html</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#B31D28;--shiki-dark:#FDAEB7;--shiki-light-font-style:italic;--shiki-dark-font-style:italic;">transition</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  &lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">span</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> :key</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;text&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;{{ text }}&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">span</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;/</span><span style="--shiki-light:#B31D28;--shiki-dark:#FDAEB7;--shiki-light-font-style:italic;--shiki-dark-font-style:italic;">transition</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span></code></pre></div><p>当 text 发生改变时, span 会随时被更新, 因此会触发过渡</p><h2 id="computed-和-watch-的区别" tabindex="-1">computed 和 watch 的区别 <a class="header-anchor" href="#computed-和-watch-的区别" aria-label="Permalink to &quot;computed 和 watch 的区别&quot;">​</a></h2><p>computed 是计算属性,也就是计算值,它更多用于计算值的场景</p><p>computed 具有缓存性,computed 的值在 getter 执行后是会缓存的，只有在它依赖的属性值改变之后，下一次获取 computed 的值时才会重新调用对应的 getter 来计算</p><p>computed 适用于计算比较消耗性能的计算场景</p><p>watch 更多的是「观察」的作用,类似于某些数据的监听回调,用于观察 props $emit 或者本组件的值,当数据变化时来执行回调进行后续操作, 无缓存性, 页面重新渲染时值不变化也会执行</p><p>我们要进行数值计算, 而且依赖于其他数据, 那么把这个数据设计为 computed, 如果你需要在某个数据变化时做一些事情, 使用 watch 来观察这个数据变化</p><h2 id="vuex-模块化后-开启命名空间后如何调用其他模块的内容" tabindex="-1">vuex 模块化后, 开启命名空间后如何调用其他模块的内容 <a class="header-anchor" href="#vuex-模块化后-开启命名空间后如何调用其他模块的内容" aria-label="Permalink to &quot;vuex 模块化后, 开启命名空间后如何调用其他模块的内容&quot;">​</a></h2><p>为了防止 store 对象由于项目复杂时变得臃肿, 可以将 store 分割成不同模块 <a href="https://vuex.vuejs.org/zh/guide/modules.html" target="_blank" rel="noreferrer">module</a></p><p>默认情况下: 不同 module 下的 action/mutation/getter 是注册在全局命名空间————这样使得多模块能够对同一 mutation 或 action 作出响应,但是所有模块下的 action/mutation/getter 都在全局命名空间下会导致代码的封装度和可用度降低, 因此可以通过添加 <span style="background-color:rgba(27,31,35,.05);color:#476582;padding:.25rem .5rem;">namespaced: true</span>方式使其成为自带命名空间的模块. 当模块被注册后，它的所有 getter、action 及 mutation 都会自动根据模块注册的路径调整命名. <a href="https://segmentfault.com/a/1190000009434398" target="_blank" rel="noreferrer">详细例子</a></p><h2 id="自定义组件使用-v-model" tabindex="-1">自定义组件使用 v-model <a class="header-anchor" href="#自定义组件使用-v-model" aria-label="Permalink to &quot;自定义组件使用 v-model&quot;">​</a></h2><p><span class="important">v-model</span> 的语法糖如下所示包装而成:</p><div class="language-html vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">html</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#B31D28;--shiki-dark:#FDAEB7;--shiki-light-font-style:italic;--shiki-dark-font-style:italic;">inpu</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> :value</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;something&quot;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> @:input</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;something = $event.target.value&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;&lt;/</span><span style="--shiki-light:#B31D28;--shiki-dark:#FDAEB7;--shiki-light-font-style:italic;--shiki-dark-font-style:italic;">inpu</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span></code></pre></div><p>当在组件上使用如下:</p><div class="language-html vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">html</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">custom-input</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> :value</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;something&quot;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> @input</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;value =&gt; { something = value }&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">custom-input</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span></code></pre></div><p>因此, 带有 <span class="important">v-model</span> 的组件的核心因该是:</p><ul><li>带有 v-model 的父组件通过绑定的 value 值（即 v-model 的绑定值）传给子组件，子组件通过 prop 接收一个 value</li><li>子组件利用 $emit 触发 input 事件，并传入新值 value 给父组件</li></ul><p><a href="https://www.cnblogs.com/coffeelovetea/p/8326115.html" target="_blank" rel="noreferrer">具体示例</a></p><h2 id="nexttick-用途" tabindex="-1">nextTick 用途 <a class="header-anchor" href="#nexttick-用途" aria-label="Permalink to &quot;nextTick 用途&quot;">​</a></h2><p>vue 在修改数据后, 视图并不会实时更新, 而是等同一事件循环中的所有数据变化完成之后, 再统一进行视图更新</p><p>例子:</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">//改变数据</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">vm.message </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;changed&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">//想要立即使用更新后的DOM。这样不行，因为设置message后DOM还没有更新</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(vm.$el.textContent); </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 并不会得到&#39;changed&#39;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">//这样可以，nextTick里面的代码会在DOM更新后执行</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">Vue.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">nextTick</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(vm.$el.textContent); </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">//可以得到&#39;changed&#39;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">});</span></span></code></pre></div><p>因此, nextTick 的应用场景: 需要在视图更新之后，基于新的视图进行操作可以使用 nextTick</p><p>如:</p><p>可以将以下操作:</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">showsou</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(){</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.showit </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> true</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> //修改 v-show</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  document.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">getElementById</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;keywords&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">).</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">focus</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()  </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">//在第一个 tick 里，获取不到输入框，自然也获取不到焦点</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>修改为:</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">showsou</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(){</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.showit </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> true</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">$nextTick</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> () {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // DOM 更新了</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    document.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">getElementById</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;keywords&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">).</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">focus</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  })</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p><a href="https://segmentfault.com/a/1190000012861862" target="_blank" rel="noreferrer">详细文章请见</a></p>`,42),n=[l];function h(p,k,r,d,E,o){return a(),i("div",null,n)}const u=s(e,[["render",h]]);export{c as __pageData,u as default};
