import{_ as s,c as i,o as a,R as t}from"./chunks/framework.Tt2DsVC6.js";const g=JSON.parse('{"title":"VUE 面试问题","description":"","frontmatter":{},"headers":[],"relativePath":"blog/interview/vue.md","filePath":"blog/interview/vue.md","lastUpdated":1745971043000}'),e={name:"blog/interview/vue.md"},l=t(`<h1 id="vue-面试问题" tabindex="-1">VUE 面试问题 <a class="header-anchor" href="#vue-面试问题" aria-label="Permalink to &quot;VUE 面试问题&quot;">​</a></h1><p>Vue 2 和 Vue 3 的响应式系统虽然功能类似，但<strong>实现原理完全不同</strong>，Vue 3 是对 Vue 2 响应式系统的一次<strong>全面升级</strong>，更灵活也更高效。</p><hr><h2 id="🎯-1-vue-2-的响应式原理" tabindex="-1">🎯 1. Vue 2 的响应式原理 <a class="header-anchor" href="#🎯-1-vue-2-的响应式原理" aria-label="Permalink to &quot;🎯 1. Vue 2 的响应式原理&quot;">​</a></h2><h3 id="✅-基于-object-defineproperty" tabindex="-1">✅ <strong>基于 <code>Object.defineProperty()</code></strong> <a class="header-anchor" href="#✅-基于-object-defineproperty" aria-label="Permalink to &quot;✅ **基于 \`Object.defineProperty()\`**&quot;">​</a></h3><p>Vue 2 在初始化时会对 <code>data</code> 对象中的每个属性使用 <code>Object.defineProperty()</code> 进行“劫持”（数据拦截）：</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">Object.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">defineProperty</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(obj, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;key&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  get</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() { </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">/* 收集依赖 */</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> },</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  set</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">newVal</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) { </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">/* 通知更新 */</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">});</span></span></code></pre></div><h3 id="👀-核心步骤" tabindex="-1">👀 核心步骤： <a class="header-anchor" href="#👀-核心步骤" aria-label="Permalink to &quot;👀 核心步骤：&quot;">​</a></h3><ol><li><p><strong>初始化阶段</strong>：</p><ul><li>遍历所有的 data 属性</li><li>使用 <code>Object.defineProperty</code> 把每个属性变成“响应式的”</li></ul></li><li><p><strong>依赖收集（Dep + Watcher）</strong>：</p><ul><li>页面渲染会读取数据的 <code>getter</code>，触发依赖收集；</li><li>数据变化时触发 <code>setter</code>，通知相关 <code>Watcher</code> 重新渲染视图。</li></ul></li><li><p><strong>数组响应式的 hack（重写原型方法）</strong>：</p><ul><li>Vue 2 不能监听数组元素的索引或 length 变化；</li><li>通过重写 <code>push</code> / <code>pop</code> / <code>splice</code> 等方法来劫持数组的变化。</li></ul></li></ol><h3 id="⚠️-缺点" tabindex="-1">⚠️ 缺点： <a class="header-anchor" href="#⚠️-缺点" aria-label="Permalink to &quot;⚠️ 缺点：&quot;">​</a></h3><ul><li><strong>只能对已存在的属性做响应式</strong>：新增属性要用 <code>$set</code>，否则不会响应。</li><li><strong>不能监听数组索引变化和 length 变化</strong>。</li><li><strong>深层嵌套对象需要递归遍历，性能开销大</strong>。</li><li><strong>静态编译不友好</strong>（难以 Tree-shaking）。</li></ul><hr><h2 id="🎯-2-vue-3-的响应式原理" tabindex="-1">🎯 2. Vue 3 的响应式原理 <a class="header-anchor" href="#🎯-2-vue-3-的响应式原理" aria-label="Permalink to &quot;🎯 2. Vue 3 的响应式原理&quot;">​</a></h2><h3 id="✅-基于-es6-的-proxy" tabindex="-1">✅ <strong>基于 ES6 的 <code>Proxy</code></strong> <a class="header-anchor" href="#✅-基于-es6-的-proxy" aria-label="Permalink to &quot;✅ **基于 ES6 的 \`Proxy\`**&quot;">​</a></h3><p>Vue 3 使用 <code>Proxy</code> 替代了 <code>Object.defineProperty</code>，直接“包裹”整个对象，从而统一拦截访问和修改行为：</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> proxy</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Proxy</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(obj, {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  get</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">target</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">key</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">receiver</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 依赖收集</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Reflect.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">get</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(target, key, receiver);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  },</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  set</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">target</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">key</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">value</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">receiver</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 派发更新</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Reflect.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">set</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(target, key, value, receiver);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">});</span></span></code></pre></div><h3 id="🧠-关键特性" tabindex="-1">🧠 关键特性： <a class="header-anchor" href="#🧠-关键特性" aria-label="Permalink to &quot;🧠 关键特性：&quot;">​</a></h3><ul><li><strong>懒加载响应式（懒代理）</strong>：只有在访问某个对象时才递归进行响应式转换，提高性能。</li><li><strong>支持对象新增/删除属性的自动响应</strong>。</li><li><strong>支持数组索引、length 等操作</strong>。</li><li><strong>支持 <code>Map</code>、<code>Set</code>、<code>WeakMap</code>、<code>WeakSet</code> 等复杂数据结构的响应式处理</strong>。</li><li><strong>使用 <code>Reflect</code> 保留原始行为，提高兼容性和一致性。</strong></li></ul><hr><h2 id="🔍-对比-vue-2-vs-vue-3-响应式系统" tabindex="-1">🔍 对比：Vue 2 vs Vue 3 响应式系统 <a class="header-anchor" href="#🔍-对比-vue-2-vs-vue-3-响应式系统" aria-label="Permalink to &quot;🔍 对比：Vue 2 vs Vue 3 响应式系统&quot;">​</a></h2><table><thead><tr><th>对比项</th><th>Vue 2 (<code>defineProperty</code>)</th><th>Vue 3 (<code>Proxy</code>)</th></tr></thead><tbody><tr><td>API 支持</td><td>只能监听已有属性</td><td>任意属性变更都能响应</td></tr><tr><td>数组响应</td><td>hack 原型方法，不支持索引响应</td><td>原生支持索引和 <code>length</code> 监听</td></tr><tr><td>数据深度监听</td><td>初始化时递归</td><td>访问时惰性代理（性能更高）</td></tr><tr><td>新增/删除属性响应</td><td>需要 <code>$set</code> / <code>$delete</code></td><td>自动响应</td></tr><tr><td>支持 Map/Set 等</td><td>不支持</td><td>支持</td></tr><tr><td>响应式转化控制</td><td>不可关闭</td><td>使用 <code>markRaw</code>、<code>shallowReactive</code> 等灵活控制</td></tr><tr><td>性能</td><td>中等，深层嵌套时递归多</td><td>更快更轻，懒代理提升性能</td></tr><tr><td>是否兼容 IE11</td><td>✅（兼容）</td><td>❌（Proxy 不支持 IE）</td></tr></tbody></table><hr><h2 id="🧪-举个例子" tabindex="-1">🧪 举个例子 <a class="header-anchor" href="#🧪-举个例子" aria-label="Permalink to &quot;🧪 举个例子&quot;">​</a></h2><h3 id="vue-2-新增属性不响应" tabindex="-1">Vue 2（新增属性不响应） <a class="header-anchor" href="#vue-2-新增属性不响应" aria-label="Permalink to &quot;Vue 2（新增属性不响应）&quot;">​</a></h3><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">vm.obj.a </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 视图不会更新，必须这样写：</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">Vue.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">set</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(vm.obj, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;a&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span></code></pre></div><h3 id="vue-3-直接新增即可响应" tabindex="-1">Vue 3（直接新增即可响应） <a class="header-anchor" href="#vue-3-直接新增即可响应" aria-label="Permalink to &quot;Vue 3（直接新增即可响应）&quot;">​</a></h3><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">reactiveObj.a </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 响应式自动处理，视图更新</span></span></code></pre></div><hr><h2 id="🧠-总结一句话" tabindex="-1">🧠 总结一句话 <a class="header-anchor" href="#🧠-总结一句话" aria-label="Permalink to &quot;🧠 总结一句话&quot;">​</a></h2><ul><li><strong>Vue 2：defineProperty，一次性递归转换，性能弱，不支持动态属性</strong></li><li><strong>Vue 3：Proxy，懒加载转换，灵活高效，支持更复杂数据结构</strong></li></ul><hr><h2 id="对-keep-alive-的理解" tabindex="-1">对 Keep-alive 的理解 <a class="header-anchor" href="#对-keep-alive-的理解" aria-label="Permalink to &quot;对 Keep-alive 的理解&quot;">​</a></h2><ul><li>keep-alive 是 Vue 内置的一个组件，能在切换组件过程中将状态保留在内存中，防止重复渲染 DOM</li><li>keep-alive 包裹动态组件时，会缓存不活动的组件实例，而不是销毁它们</li><li>keep-alive 可以设置以下 props： <ul><li>include: 字符串或正则表达式。只有匹配的组件会被缓存</li><li>exclude: 字符串或正则表达式。任何匹配的组件都不会被缓存</li><li>max: 最多可以缓存多少组件实例</li></ul></li><li>keep-alive 匹配首先检查组件的 name 选项，如果 name 选项不可用，则匹配它的局部注册名称(父组件 components 选项的键值)，匿名组件不能被匹配</li><li>keep-alive 的生命周期钩子: <ul><li>activated</li><li>deactivated</li></ul></li></ul><h2 id="双向数据绑定" tabindex="-1">双向数据绑定 <a class="header-anchor" href="#双向数据绑定" aria-label="Permalink to &quot;双向数据绑定&quot;">​</a></h2><p>vue 采用 <b>数据劫持</b> 结合 <b>发布-订阅者模式</b> 的方式, 通过 <span class="important">Object.defineProperty()</span> 来劫持各个属性的 <b>setter</b> 以及 <b>getter</b>, 在数据变动时发布消息给订阅者触发相应的监听回调.</p><h2 id="vue-项目优化" tabindex="-1">vue 项目优化 <a class="header-anchor" href="#vue-项目优化" aria-label="Permalink to &quot;vue 项目优化&quot;">​</a></h2><ul><li>关闭 sourceMap: 进行打包源码上线环节，需要对项目开发环节的开发提示信息以及错误信息进行屏蔽, 一方面可以减少上线代码包的大小; 另一方面提高系统的安全性.</li><li>对项目中的 js/css/svg 等资源开启 gzip 压缩</li><li>路由懒加载:</li></ul><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  path</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;index&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  component</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: () </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;@/views/user/index&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><ul><li>第三方插件按需引入</li><li>代码优化 <ul><li>v-if 和 v-show 选择调用: v-if 是懒加载，当状态为 true 时才会加载, 并且为 false 时不会占用布局空间; v-show 是无论状态是 true 或者是 false, 都会进行渲染，并对布局占据空间对于在项目中, 需要频繁调用, 不需要权限的显示隐藏，可以选择使用 v-show, 可以减少系统的切换开销.</li><li>列表循环时为 item 设置 key 值</li><li>减少 watch 数据: watch 监听的数据较大时, 系统会出现卡顿</li><li>系统图片资源按需加载</li></ul></li><li>提取 css 文件: vue-cli 脚手架使用了 extract-text-webpack-plugin 插件,可以将放在 head 中的 style 提取成 css 文件引入</li></ul><h2 id="vue-中-key-值的作用" tabindex="-1"><a href="https://cn.vuejs.org/v2/api/#key" target="_blank" rel="noreferrer">vue 中 key 值的作用</a> <a class="header-anchor" href="#vue-中-key-值的作用" aria-label="Permalink to &quot;[vue 中 key 值的作用](https://cn.vuejs.org/v2/api/#key)&quot;">​</a></h2><ul><li>v-for 列表循环中的 key: 作用就是在更新组件时判断两个节点是否相同。相同就复用，不相同就删除旧的创建新的.</li><li>其他作用: 用于强制更新元素/组件而不是重复使用 <ul><li>触发过渡</li><li>完整地触发组件的生命周期钩子</li></ul></li></ul><p>例如:</p><div class="language-html vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">html</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#B31D28;--shiki-dark:#FDAEB7;--shiki-light-font-style:italic;--shiki-dark-font-style:italic;">transition</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  &lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">span</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> :key</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;text&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;{{ text }}&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">span</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;/</span><span style="--shiki-light:#B31D28;--shiki-dark:#FDAEB7;--shiki-light-font-style:italic;--shiki-dark-font-style:italic;">transition</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span></code></pre></div><p>当 text 发生改变时, span 会随时被更新, 因此会触发过渡</p><h2 id="computed-和-watch-的区别" tabindex="-1">computed 和 watch 的区别 <a class="header-anchor" href="#computed-和-watch-的区别" aria-label="Permalink to &quot;computed 和 watch 的区别&quot;">​</a></h2><p>computed 是计算属性,也就是计算值,它更多用于计算值的场景</p><p>computed 具有缓存性,computed 的值在 getter 执行后是会缓存的，只有在它依赖的属性值改变之后，下一次获取 computed 的值时才会重新调用对应的 getter 来计算</p><p>computed 适用于计算比较消耗性能的计算场景</p><p>watch 更多的是「观察」的作用,类似于某些数据的监听回调,用于观察 props $emit 或者本组件的值,当数据变化时来执行回调进行后续操作, 无缓存性, 页面重新渲染时值不变化也会执行</p><p>我们要进行数值计算, 而且依赖于其他数据, 那么把这个数据设计为 computed, 如果你需要在某个数据变化时做一些事情, 使用 watch 来观察这个数据变化</p><h2 id="vuex-模块化后-开启命名空间后如何调用其他模块的内容" tabindex="-1">vuex 模块化后, 开启命名空间后如何调用其他模块的内容 <a class="header-anchor" href="#vuex-模块化后-开启命名空间后如何调用其他模块的内容" aria-label="Permalink to &quot;vuex 模块化后, 开启命名空间后如何调用其他模块的内容&quot;">​</a></h2><p>为了防止 store 对象由于项目复杂时变得臃肿, 可以将 store 分割成不同模块 <a href="https://vuex.vuejs.org/zh/guide/modules.html" target="_blank" rel="noreferrer">module</a></p><p>默认情况下: 不同 module 下的 action/mutation/getter 是注册在全局命名空间————这样使得多模块能够对同一 mutation 或 action 作出响应,但是所有模块下的 action/mutation/getter 都在全局命名空间下会导致代码的封装度和可用度降低, 因此可以通过添加 <span style="background-color:rgba(27,31,35,.05);color:#476582;padding:.25rem .5rem;">namespaced: true</span>方式使其成为自带命名空间的模块. 当模块被注册后，它的所有 getter、action 及 mutation 都会自动根据模块注册的路径调整命名. <a href="https://segmentfault.com/a/1190000009434398" target="_blank" rel="noreferrer">详细例子</a></p><h2 id="自定义组件使用-v-model" tabindex="-1">自定义组件使用 v-model <a class="header-anchor" href="#自定义组件使用-v-model" aria-label="Permalink to &quot;自定义组件使用 v-model&quot;">​</a></h2><p><span class="important">v-model</span> 的语法糖如下所示包装而成:</p><div class="language-html vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">html</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#B31D28;--shiki-dark:#FDAEB7;--shiki-light-font-style:italic;--shiki-dark-font-style:italic;">inpu</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> :value</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;something&quot;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> @:input</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;something = $event.target.value&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;&lt;/</span><span style="--shiki-light:#B31D28;--shiki-dark:#FDAEB7;--shiki-light-font-style:italic;--shiki-dark-font-style:italic;">inpu</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span></code></pre></div><p>当在组件上使用如下:</p><div class="language-html vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">html</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">custom-input</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> :value</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;something&quot;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> @input</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;value =&gt; { something = value }&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">custom-input</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span></code></pre></div><p>因此, 带有 <span class="important">v-model</span> 的组件的核心因该是:</p><ul><li>带有 v-model 的父组件通过绑定的 value 值（即 v-model 的绑定值）传给子组件，子组件通过 prop 接收一个 value</li><li>子组件利用 $emit 触发 input 事件，并传入新值 value 给父组件</li></ul><p><a href="https://www.cnblogs.com/coffeelovetea/p/8326115.html" target="_blank" rel="noreferrer">具体示例</a></p><h2 id="nexttick-用途" tabindex="-1">nextTick 用途 <a class="header-anchor" href="#nexttick-用途" aria-label="Permalink to &quot;nextTick 用途&quot;">​</a></h2><p>vue 在修改数据后, 视图并不会实时更新, 而是等同一事件循环中的所有数据变化完成之后, 再统一进行视图更新</p><p>例子:</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">//改变数据</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">vm.message </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;changed&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">//想要立即使用更新后的DOM。这样不行，因为设置message后DOM还没有更新</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(vm.$el.textContent); </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 并不会得到&#39;changed&#39;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">//这样可以，nextTick里面的代码会在DOM更新后执行</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">Vue.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">nextTick</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(vm.$el.textContent); </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">//可以得到&#39;changed&#39;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">});</span></span></code></pre></div><p>因此, nextTick 的应用场景: 需要在视图更新之后，基于新的视图进行操作可以使用 nextTick</p><p>如:</p><p>可以将以下操作:</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">showsou</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(){</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.showit </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> true</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> //修改 v-show</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  document.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">getElementById</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;keywords&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">).</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">focus</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()  </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">//在第一个 tick 里，获取不到输入框，自然也获取不到焦点</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>修改为:</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">showsou</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(){</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.showit </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> true</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">$nextTick</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> () {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // DOM 更新了</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    document.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">getElementById</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;keywords&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">).</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">focus</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  })</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p><a href="https://segmentfault.com/a/1190000012861862" target="_blank" rel="noreferrer">详细文章请见</a></p>`,72),n=[l];function h(p,k,r,d,o,E){return a(),i("div",null,n)}const u=s(e,[["render",h]]);export{g as __pageData,u as default};
